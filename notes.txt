Algorithm func (L)
	Input: A list L storing distinct integers.
	Output: Sum of all even numbers in the list except 2.

sum <= 0
n <= size of L
for i <= 0 to n - 1 do
	if L[i] mod 2 = 0 and L[i] != 2 then
		sum <= sum + L[i]

return sum

Chapter 1

Roster Notation:
A = {2, 4, 6, 8}
Set Builder Notation
B = {x in Z: x % 2 == 0, x > 0} (Z: all integer)

S = {a, b}

Membership in Set:

a in S
a, b in S
c not in S

{1, 2, 3} == {3, 1, 2}
{1, 1, 2, 3} == {1, 2, 3}
{1, 3, 5} != {1, 4, 5}

B in A if all elem in B are in A
let A = [1, 2, 3, 4, 5];
let subsets_in = [
	[1, 2, 3], //true
]

subset: x contained in A
{3, 1, 2} == {1, 2, 3, 4, 5}
{3, 3, 1, 2} == {1, 2, 3}
3 != {1, 2, 3} // not set
{1, 2, 3} == 1, 2, 3
proper subset
{1, 2} == {1, 2, 3} // not required to have all elems
{1} == {1, 2, 3}
{1, 2 ,3} != {4, 1, 2 ,3 }
3 != {1, 2, 3}

if one is a subset, then it CANNOT be a proper subset

cardinality: number of unique elems

N: x >= 0
Z: parseInt
Q: a/b => 1/2, 2/3, 3/4,... 5.23, ...
R: pi, sqrt(2)


Complex: a + bi
Imaginary: ai

Z+, R-,...

S = NULL

empty set is subset of every set

empty set is subset of itself

function is_subset(set1, set2) { // all elements in set1 is in set2
	for (let i = 0; i < set1.length; ++ i) {
		for (let j = 0; i < set2.length; ++ j) {

		}
	}
}

set can represent using venn diagrams

union: {1, 2, 3, 4} + {3, 4, 5, 6} = {1, 2, 3, 4, 5, 6} ( U )
intersect: {1, 2, 3, 4} and {3, 4, 5, 6} = {3, 4} ( U but more like ^ )
{1, 2} and {3, 4} = NULL (a.k.a disjoint)
diff: {3, 4, 5, 6} - {1, 2, 3, 4} = {5, 6}
	 {1, 2, 3, 4} - {3, 4, 5, 6} = {1, 2}
xor (symmetric diff): {1, 2, 3, 4} xor {3, 4, 5, 6} = {1, 2, 5, 6}
complement (not exist in a set): {2, 3, 4, 5} comp {4, 5, 6}, {1, 7} = {1, 6, 7}

partition (sum)
	{x in Z: 3 <= x <= 9}
	B {3, 4, 5} + C {6, 7, 8} + D {9} + E {3, 4, 5, 6, 7}

cross
	{2, -3, 0, 1.5} x {3, 1, 0, -2.5}
	{(0, 0), (0, 1),...} // all possible pair
	A{} x B{} x C{} = {(x, x, x), (x, x, x), ...} // now triple
	{1, 2, 3} x {4, 5} = {(1, 4), (1, 5), (2, 4), (2, 5), ...}

string notation: A{x, y} x B{a, b} = {xa, xb, ya, yb} // no ()

power set (S)
S = {1, 2 ,3}
P(S) = {
	NULL,
	{1}, {2}, {3},
	{1, 2}, {1, 3}, {2, 3},
	{1, 2, 3}
}

tuple != set ( () != {} )
(3, 6, 9) == (3, 6, 9) != (3, 9, 6)
(1, 2, 3) != (1, 1, 2, 3) // allow dupe
(2**2, 3**2) == (4, 9)

  1
 / \
/   \
|   | M_i
|   |
i = 3

A U S
{x: x in A OR x in S} (OR here, NOT AND)

Universal set: U

A = {a, b}   B = {b, c}
P(A) ∩ P(B)

{NULL, {a}, {b}, {a, b}} - {NULL, {b}, {c}, {b, c}} = {{a}, {a, b}}

A = {tall, grande, venti}
B = {foam, no-foam}
C = {non-fat, whole}


function sss(a) {
	let ret = [];
	for (let i = 0; i < a.length; ++ i) {
		let e = a[i];
		for (let j = 0; j < e.length; ++ j) {
			let temp = [];
			for (let k = 0; k < ) {

			}
			ret.push(temp);
		}
	}
}

A × B × C

{tall}

B × A × C
B × C using roster notation.

{0x: x ∈ {0, 1}2}

{00, 01, 10, 11} {000, 001, 010, 011}

{0x: x ∈ B}, where B = {0, 1}0 ∪ {0, 1}1 ∪ {0, 1}2

{NULL, 00, 01, 10, 11}

{xy: x ∈ {aa, ab} and y ∈ {a} ∪ {a}2}

{a} ∪ {a}2 {aa}

{a, aa} {aaa, aaaa, aba, abaa}

Chapter 2

Logic

T F
non-const value cannot be T or F
p q r s for vars


Sorted by operator pre
~p (NOT)
p ^ q (AND)
p ∨ q (OR)
p ⊕ q (XOR)
p -> q (if p then q)
p <-> q (XNOR) (a.k.a biconditional) ()

if then:
T | T > T
T | F > F
F | T > T
F | F > T

T | T > T
T | F > F
F | F > T ??

T | T > T
T | F > F
F | T > T ??

https://www.allaboutcircuits.com/technical-articles/universal-logic-gates/

one of q or p is true (xor)

(p v q) ^ ~(p ^ q) xor

Tautology: always true
Contradction: always false

converse        q -> p
contrapositive ~q -> ~p
inverse        ~p -> ~q

If rain, then close window.
	If close window, then rain.
	If don't close window, then not rain.
	Don't close window if not rain.

        De Morgan law
     ~(p ^ q) = ~p V ~q
     ~(p V q) = ~p ^ ~q

(p -> q) -> r ~= p -> (q -> r)

          Laws:
     p -> q = ~p v q
    p <-> q = (p -> q) ^ (q -> p)

p V (p ^ q) = p ^ (p V q) = p

(p v q) v r = p v (q v r)
(p ^ q) ^ r = p ^ (q ^ r)

p v (q ^ r) = (p v q) ^ (p v r)
p ^ (q v r) = (p ^ q) v (p ^ r)


(p v ~q) ^ (~p v ~q) = ~q

(p || !q) && (!p || !q)
(p || !q) && !(p && q)
!q || (p && !p)
~q || F
!q

p -> (p v q)
~p || (p || q)
(~p || p) || q
T || q
T

(p v q) ^ (p v r) ^ (q v r)
q ^ r v p ^ (q v r)

q ^ r ^ p v (q v r)

(p ∧ ¬q) ∨ (p ∧ q) = p ∧ (¬q ∨ q) ?????

var res = [];
function test(a, b, c) {
	return (a || b) && (a || c) && (b || c);
}
for (let i = 0; i < Math.pow(2, 3); ++ i) {
	res.push(test(i >> 2 & 1, i >> 1 & 1, i & 1));
}
console.log(res);

Preposition: always constant value
Predicates: how much variables a statement can be

R(x) is predicate x > 5

Preposition:
R(23) is true, R(-5) is false

∀: all
∃: any

let x ∈ R
∀x (x^2 > x) -> false
             -> counter example

∀y ∈ 2^+ (1/y <= y) True

Every freshman at the College is taking CS 101

Q(x, y) = student x is taking course y

∀s ∈ College, Q(s, CS101)

P(x) = x is lion, Q(x) = x is fierce, R(x) = x drinks coffee

Some lions do not drink coffee
∃x, (P(x) ^ ~R(x))

All lion are fierce
∀x, (P(x) -> R(x))

~∀x P(x) = ∃x ~P(x)
∀x ~P(x) = ~∃x P(x)

Argument => sequence of proposition
g: good golf
c: wind calm
d: weather dry

g -> (c v d)
c ^ d
g

g c d | c ^ d | g -> (c v d) | g |
T T T |   T   |       T      | T | T   X
T T F |   T   |       T      | F | T    
T F T |   T   |       T      | T | F   X
T F F |   T   |       T      | F | F    
F T T |   T   |       T      | F | T    
F T F |   T   |       T      | F | T    
F F T |   F   |       F      | F | F    
F F F |   F   |       T      | F | F    

=> Invalid

Rule of inference

~p ^ q
r -> p
~r -> s
s -> t
-------
∴ t

Basically this is just a fancy way of "sum" all "and"

~q
p -> q
--------
∴ ((p → q) ∧ ¬q) → ¬p

~p ^ q (premise)
~p (simplication 1)
r -> p (premise)
~r (modus tollens 2, 3)
~r -> s (premise)
s (modus tollens 4, 5)
s -> t (premise)
t (modus tollens 6, 7)

p v f
~t -> ~p  (~~t v ~p) (~p v t) -> (f v t) (t v f)
t -> b    (~t v b) -> (f v b)
~f
∴ b

p -> q  (~p v q) (q v ~p)
q -> r  (~q v r) -> (~p v r) (p -> r)
~r      -> p
∴ p

function

f(x)

each element in X is assigned one value and only one

f(x) as set of ordered pair

range is what f(x) can reach
target is all possible result

3(2x+4)^2+6(2x+4)+12
3(2x+4)^2+12x+24+12

one-to-one: every input will have different output
onto: A->B, as every possible value in B MUST BE USED by A

bijection: both

piecewise is not invertible ?
